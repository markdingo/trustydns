#! /usr/bin/env perl

# Analyze the log entries produced by trustydns-proxy and produce a report that is easier to read
# than the condensed log entries. Typically usage might be to pipe in a 24hour period of log entries
# into this program to produce a daily report.
#
# This program is obviously version dependent as trustydns-proxy logging details can readily change
# between versions.

use warnings;
use strict 'vars';
use Getopt::Std;

# We purposely hard-code the version in this analysis program as an automated import risks a version
# change without anyone inspecting this code. It's rarely likely to be the case that a version
# change occurs without *some* changes to the stats reporting. At least in the early stages of this
# package.

my $expectedVersion = "v0.1.0";
my $currentVersion = "";

##########

sub usage($$)
{
    print "Error: $_[0]\n" if length $_[0];
    shift;
    print "
Usage: tdt-analyze-proxylog [-h] [-eSW]

This program analyzes the logging output generated by trustydns-proxy and produces a more
user-friendly report containing columns with headings and summaries across the whole logging period.

Log lines are supplied via stdin or filenames on the command line.

Where:
      -h Print usage message and exit 0

      -S Suppress summary report (normally printed)

      -W Suppress warnings messages when patterns mismatch (normally printed)

Version: $expectedVersion

";

    exit(shift);
}

##########
# MAIN

my %opts;
usage("", 1) unless getopts('eSW', \%opts);
usage("", 0) if defined $opts{h};
my $reportSummary = ! defined $opts{S};
my $printWarnings = ! defined $opts{W};

my $listeners = {};		# Running totals are kept in these set of variables
my $localResolver = {};
$localResolver->{Servers} = {};
my $DoHResolver = {};
$DoHResolver->{Servers} = {};
my $biasUptime = 0;
my $runningUptime = 0;
my $totalUptime = 0;
my $totalLines = 0;
my $analyzedLines = 0;
my $skippedLines = 0;
my $startCount = 0;
my $exitCount = 0;

my $lines = {};			# Track how many successful lines were processed
$lines->{listeners} = 0;
$lines->{localResolver} = 0;
$lines->{DoHResolver} = 0;

my $dispatch = {};

$dispatch->{listener}->{matchRegex} = 'Starting Server: \(on (\S+)\)';
$dispatch->{listener}->{detailRegex} = '(\S+)';
$dispatch->{listener}->{handler} = \&Listener;

$dispatch->{listenerStats}->{matchRegex} = 'Status Server: (.*)';
$dispatch->{listenerStats}->{detailRegex} = '\(on (\S+)\): req=(\d+) ok=(\d+) \((\d+)\/(\d+)\) al=(\S+) errs=(\d+) \((\d+)\/(\d+)\) Concurrency=(\d+)';
$dispatch->{listenerStats}->{handler} = \&ListenerStats;

$dispatch->{localResolverTotals}->{matchRegex} = 'Status Local Resolver: Totals: (.*)';
$dispatch->{localResolverTotals}->{detailRegex} = 'req=(\d+) ok=(\d+) errs=(\d+) \((\d+)\/(\d+)\)';
$dispatch->{localResolverTotals}->{handler} = \&LocalResolverTotals;

$dispatch->{localResolverServer}->{matchRegex} = 'Status Local Resolver: Server: (.*)';
$dispatch->{localResolverServer}->{detailRegex} = 'req=(\d+) ok=(\d+) al=(\S+) errs=(\d+) \((\d+)\/(\d+)\/(\d+)\/(\d+)\/(\d+)\/(\d+)\) \(ev (\d+)\/(\d+)\) (\S+)';

$dispatch->{localResolverServer}->{handler} = \&LocalResolverServer;

$dispatch->{dohResolverTotals}->{matchRegex} = 'Status DoH Resolver: Totals: (.*)';
$dispatch->{dohResolverTotals}->{detailRegex} = 'req=(\d+) ok=(\d+) errs=(\d+) \((\d+)\/(\d+)\)';
$dispatch->{dohResolverTotals}->{handler} = \&DoHResolverTotals;

$dispatch->{dohResolverServer}->{matchRegex} = 'Status DoH Resolver: Server: (.*)';
$dispatch->{dohResolverServer}->{detailRegex} = 'ok=(\d+) tl=(\S+) rl=(\S+) errs=(\d+) \((\d+)\/(\d+)\/(\d+)\/(\d+)\/(\d+)\/(\d+)\) \(ecs (\d+)\/(\d+)\/(\d+)\/(\d+)\) (\S+)';
$dispatch->{dohResolverServer}->{handler} = \&DoHResolverServer;


while (<>) {
    chomp;
    &matchAndDispatch($_);
}

# Post analysis cleanups

$totalUptime += $runningUptime - $biasUptime;	# Include final instance uptime
$totalUptime = 0.001 if $totalUptime <= 0;	# Eliminate tedious divide by zero checking

if ($reportSummary) {
    &printServer();
    &printListener();
    &printLocalResolver();
    &printDoHResolver();
}

exit(0);


##########
# trustydns-proxy v0.0.9 Starting: [https://...

sub Starting($$) {
    $currentVersion = shift;
    if ($currentVersion ne $expectedVersion) {
	print STDERR "Warning @ $.:Version mismatch. Want $expectedVersion, got $currentVersion\n" if $printWarnings;
	return;
    }
    $startCount++;
    $totalUptime += $runningUptime - $biasUptime; # Accumulate previous instance uptime
    $runningUptime = 0;
    $biasUptime = 0;
}


##########
# trustydns-proxy v0.0.1 Exiting after ...

sub Exiting($$) {
    my $version = shift;
    return unless $version eq $expectedVersion;
    my $uptime = shift;
    $exitCount++;
    $currentVersion = "";
}


##########
# Status Up: trustydns-proxy v0.0.9 19h52m4s

sub StatusUp($$) {
    $currentVersion = shift;
    return unless $currentVersion eq $expectedVersion;

    my $uptime = shift;
    my ($hh, $mm, $ss) = (0, 0, 0);
    $hh = $1 if $uptime =~ /(\d+)h/;
    $mm = $1 if $uptime =~ /(\d+)m/;
    $ss = $1 if $uptime =~ /(\d+)s/;
    my $nextRunningUptime = ((($hh * 60) + $mm) * 60) + $ss;
    if ($nextRunningUptime < $runningUptime) {	# Restarted?
	$totalUptime += $runningUptime - $biasUptime;
	$biasUptime = 0;
    }
    $runningUptime = $nextRunningUptime;
    if ($startCount == 0 && $biasUptime == 0) { # If we haven't seen a start then we need to bias the uptime
	$biasUptime = $runningUptime;
    }
}


##########
# Starting Server: (on 203.0.120.139:53/udp

sub Listener {
    my $listener = $1;
    $listeners->{$listener} = {} unless exists $listeners->{$listener}; # Create an entry for this listen address
}


##########
# Status Server: (on 127.0.0.139:53/udp): req=0 ok=0 (1/0) al=0.000 errs=0 (0/0) Concurrency=0
#                    $1                       2    3  4 5     6          7  8 9              10

sub ListenerStats {
    $lines->{listeners}++;
    my $listener = $1;
    my $al = $6;
    $al = 0.0 if $al eq "NaN";
    $listeners->{$listener}->{req} += $2;
    $listeners->{$listener}->{ok} += $3;
    $listeners->{$listener}->{evTruncated} += $4;
    $listeners->{$listener}->{ev2} += $5;
    $listeners->{$listener}->{totalLatency} += $3 * $al;
    $listeners->{$listener}->{totalErrors} += $7;
    $listeners->{$listener}->{errNoResponse} += $8;
    $listeners->{$listener}->{errDNSWriteFailed} += $9;
    $listeners->{$listener}->{PeakConcurrency} = $10
	if !defined $listeners->{$listener}->{PeakConcurrency} or $10 > $listeners->{$listener}->{PeakConcurrency};
}


##########
# v0.0.9: Status Local Resolver: Totals: req=123 ok=99 errs=24 (8/16)
#                                            $1     2       3   4 5
#
sub LocalResolverTotals {
    $lines->{localResolver}++;
    $localResolver->{req} += $1;
    $localResolver->{ok} += $2;

    $localResolver->{totalErrors} += $3;
    $localResolver->{errRTT} += $4;
    $localResolver->{errRetries} += $5;
}


##########
# v0.0.9 Status Local Resolver: Server: req=6 ok=6 al=0.194 errs=0 (0/0/0/0/0/0) (ev 0/0) 127.0.0.1:53
#                                           $1   2    3          4  5/6/7/8/9/10    11/12 13
sub LocalResolverServer {
    $lines->{localResolver}++;
    my $name = $13;
    my $al = $3;
    $al = 0.0 if $al eq "NaN";
    $localResolver->{Servers}->{$name}->{req} += $1;
    $localResolver->{Servers}->{$name}->{ok} += $2;
    $localResolver->{Servers}->{$name}->{latency} += $2 * $3;
    $localResolver->{Servers}->{$name}->{errs} += $4;
    $localResolver->{Servers}->{$name}->{sfxExchangeError} += $5;
    $localResolver->{Servers}->{$name}->{sfxFormatError} += $6;
    $localResolver->{Servers}->{$name}->{sfxServerFail} += $7;
    $localResolver->{Servers}->{$name}->{sfxRefused} += $8;
    $localResolver->{Servers}->{$name}->{sfxNotImplemented} += $9;
    $localResolver->{Servers}->{$name}->{sfxOther} += $10;
    $localResolver->{Servers}->{$name}->{evxTCPFallback} += $9;
    $localResolver->{Servers}->{$name}->{evxTCPSuperior} += $10;
}


##########
# Status DoH Resolver: Totals: req=159 ok=159 errs=0 (0/0)
#                                  $1     2        3  4 5

sub DoHResolverTotals {
    $lines->{DoHResolver}++;
    $DoHResolver->{req} += $1;
    $DoHResolver->{ok} += $2;
    $DoHResolver->{errs} += $3;
    $DoHResolver->{dgxPackDNSQuery} += $4;
    $DoHResolver->{dgxRFFU} += $5;
}

##########
# Status DoH Resolver: Server: ok=86 tl=0.062 rl=0.043 errs=0 (0/0/0/0/0/0) (ecs 0/93/86/0) https://..
#                                 $1    2        3          4  5 6 7 8 9 10     11 12 13 14 15

sub DoHResolverServer($) {
    $lines->{DoHResolver}++;
    my $tl = $2;
    $tl = 0.0 if $tl eq "NaN";
    my $rl = $3;
    $rl = 0.0 if $rl eq "NaN";
    my $server = $15;

    $DoHResolver->{Servers}->{$server}->{ok} += $1;
    $DoHResolver->{Servers}->{$server}->{totalLatency} += $1 * $tl;
    $DoHResolver->{Servers}->{$server}->{remoteLatency} += $1 * $rl;
    $DoHResolver->{Servers}->{$server}->{errs} += $4;
    $DoHResolver->{Servers}->{$server}->{dexCreateHTTPRequest} += $5;
    $DoHResolver->{Servers}->{$server}->{dexDoRequests} += $6;
    $DoHResolver->{Servers}->{$server}->{dexNonStatusOk} += $7;
    $DoHResolver->{Servers}->{$server}->{dexResponseReadAll} += $8;
    $DoHResolver->{Servers}->{$server}->{dexContentType} += $9;
    $DoHResolver->{Servers}->{$server}->{dexUnpackDNSResponse} += $10;

    $DoHResolver->{Servers}->{$server}->{ECSRemoved} += $11;
    $DoHResolver->{Servers}->{$server}->{ECSSet} += $12;
    $DoHResolver->{Servers}->{$server}->{ECSRequest} += $13;
    $DoHResolver->{Servers}->{$server}->{ECSReturned} += $14;
}


##########
# Tease out the type and type-specific data then dispatch to type-specific handler. Pattern matching
# purposely ignores prefix goop such as timestamps and application identifiers which are added by
# the likes of syslog or multilog.

sub matchAndDispatch($) {
    $_ = shift;
    $totalLines++;
    if (/trustydns-proxy (\S+) Starting: \[(.*)\]$/) {
	&Starting($1, $2);
	return;
    }

    if (/trustydns-proxy (\S+) Exiting after (\S+)/) {
	&Exiting($1, $2);
	return;
    }

    if (/Status Up: trustydns-proxy (\S+) (\w+)/) {
	&StatusUp($1, $2);
	return;
    }

    # Don't try and analyze any other lines if we're in the wrong version

    if ($currentVersion ne $expectedVersion) {
	$skippedLines++;
	return;
    }

    foreach my $handlerName (keys %{$dispatch}) { # Find the matching pattern and handler
	my $matchRegex = $dispatch->{$handlerName}->{matchRegex};
	if (/$matchRegex/) {
	    $_ = $1;
	    my $detailRegex = $dispatch->{$handlerName}->{detailRegex};
	    my $handler = $dispatch->{$handlerName}->{handler};
	    if (/$detailRegex/) {
		$analyzedLines++;
		&${handler}();
	    } else {
		print STDERR "Warning @ $.: Detail Regex failed for handler: $handlerName\n" if $printWarnings;
	    }
	    return;
	}
    }

    $skippedLines++;
}


##########

sub printServer() {
    my $ss = $totalUptime;
    my $day = $ss / 86400;
    $ss %= 86400;
    my $hh = $ss / 3600;
    $ss %= 3600;
    my $mm = $ss / 60;
    $ss %= 60;

    printf("Lines: %d Analyzed: %d, Skipped: %d. Total UpTime: %dd%dh%dm%ds, Server Starts: %d, exits: %d.\n",
	   $totalLines, $analyzedLines, $skippedLines, $day, $hh, $mm, $ss, $startCount, $exitCount);
}


##########

sub printListener() {
    printf("\n                              [Listen Interfaces - input lines=%d]\n\n", $lines->{listeners});
    my @listenerKeys = sort keys %{$listeners};
    if (!@listenerKeys) {
	print STDERR "Warning: No Listen interfaces found in log file\n" if $printWarnings;
	return;
    }

    if ($lines->{listeners} == 0) {
	print STDERR "Warning: No Listen stats found in log file\n" if $printWarnings;
	return;
    }
	
    my $header = "%6s %6s %7s %7s %7s %7s %7s %7s %7s  %9s\n";
    my $detail = "%6d %6.3f %7d %7d %7.3f %7d %7d %7d %7d  %9s\n";
    my $sep = "------ ------ ------- ------- ------- ------- ------- ------- -------  ---------\n";
    printf($header, "", "", "Peak", "", "", "TC=1", "", "Err", "Err", "");
    printf($header, "Total", "Req/", "Concur-", "Good", "Good", "set for", "Failed", "No Re-", "DNS", "Interface");
    printf($header, "Reqs", "Second", "rency", "Reqs", "Latency", "Client", "Reqs", "sponse", "Write", "Index");
    print $sep;

    my $totals = {};
    $totals->{req} = 0;
    $totals->{PeakConcurrency} = 0;
    $totals->{ok} = 0;
    $totals->{evTruncated} = 0;
    $totals->{totalLatency} = 0;
    $totals->{totalErrors} = 0;
    $totals->{errNoResponse} = 0;
    $totals->{errDNSWriteFailed} = 0;

    my $ix = 0;
    foreach my $listener (@listenerKeys) {
	my $l = $listeners->{$listener};
	my $rps = $l->{req} / $totalUptime;
	my $latency = 0;
	$latency = $l->{totalLatency} / $l->{ok} if $l->{ok} > 0;
	printf($detail, $l->{req}, $rps, $l->{PeakConcurrency},
	       $l->{ok}, $latency, $l->{evTruncated}, $l->{totalErrors}, $l->{errNoResponse}, $l->{errDNSWriteFailed},
	       $ix);
	$ix++;

	$totals->{req} += $l->{req};
	$totals->{PeakConcurrency} = $l->{PeakConcurrency} if $l->{PeakConcurrency}  > $totals->{PeakConcurrency};
	$totals->{ok} += $l->{ok};
	$totals->{evTruncated} += $l->{evTruncated};
	$totals->{totalLatency} += $l->{totalLatency};
	$totals->{totalErrors} += $l->{totalErrors};
	$totals->{errNoResponse} += $l->{errNoResponse};
	$totals->{errDNSWriteFailed} += $l->{errDNSWriteFailed};
    }
    print $sep;
    my $rps = $totals->{req} / $totalUptime;
    my $latency = 0;
    $latency = $totals->{totalLatency} / $totals->{ok} if $totals->{ok} > 0;
    printf($detail, $totals->{req}, $rps, $totals->{PeakConcurrency},
	   $totals->{ok}, $latency, $totals->{evTruncated},
	   $totals->{totalErrors}, $totals->{errNoResponse}, $totals->{errDNSWriteFailed},
	   "Totals");
    print $sep;

    print "\n                              [Listener Legend]\n\n";
    print "Index  Interface\n";
    print "-----  ---------------------------------------------\n";
    $ix = 0;
    foreach my $listener (@listenerKeys) {
	printf("%5d  %s\n", $ix, $listener);
	$ix++;
    }
    print "-----  ---------------------------------------------\n";
}


##########

sub printLocalResolver() {
    printf("\n                              [Local Resolver - input lines=%d]\n\n", $lines->{localResolver});
    if ($lines->{localResolver} == 0) {
	print STDERR "Warning: No Local Resolvers found in log file\n" if $printWarnings;
	return;
    }

    &printLocalResolverGeneral();
    if (%{$localResolver->{Servers}}) {
	print "\n                              [Local Resolvers]\n\n";
	&printLocalResolverServers();
	print "\n                              [Local Resolver Legend]\n\n";
	&printLocalResolverLegend();
    }
}

##########

sub printLocalResolverGeneral() {
    my $header = "%7s %7s %7s %7s %7s\n";
    my $detail = "%7d %7d %7d %7d %7d\n";
    my $sep = "------- ------- ------- ------- -------\n";
    printf($header, "Total", "Good", "Error", "Exceed", "Exceed");
    printf($header, "Reqs", "Reqs", "Reqs", "RTT", "Retries");
    print $sep;

    printf($detail, $localResolver->{req}, $localResolver->{ok},
	   $localResolver->{totalErrors}, $localResolver->{errRTT}, $localResolver->{errRetries});
    print $sep;
}

##########

sub printLocalResolverServers() {
    my $header = "%9s %9s %9s %9s %9s  %8s\n";
    my $detail = "%9d %9.3f %9d %9d %9.3f  %8s\n";
    my $sep = "--------- --------- --------- --------- ---------  --------\n";
    printf($header, "Total", "Req/", "Good", "Error", "Avg", "Resolver");
    printf($header, "Reqs", "Second", "Reqs", "Reqs", "Latency", "Index");
    print $sep;
    my $totals = {};
    my $six = 0;
    foreach my $server (sort (keys %{$localResolver->{Servers}})) {
	my $d = $localResolver->{Servers}->{$server}; # Reduce RSI
	my $latency = $d->{latency};
	$latency /= $d->{ok} if $d->{ok} > 0;
	printf($detail,
	       $d->{req},
	       $d->{req} / $totalUptime,
	       $d->{ok},
	       $d->{errs},
	       $latency,
	       $six);
	$six++;

	$totals->{req} += $d->{req};
	$totals->{ok} += $d->{ok};
	$totals->{errs} += $d->{errs};
    }
    print $sep;
    my $latency = 0;
    $latency /= $totals->{ok} if $totals->{ok} > 0;
    printf($detail,
	   $totals->{req},
	   $totals->{req} / $totalUptime,
	   $totals->{ok},
	   $totals->{errs},
	   $latency,
	   "Totals");
    print $sep;

    print "\n";

    $header = "%8s %8s %8s %8s %8s %8s %8s %8s  %8s\n";
    $detail = "%8d %8d %8d %8d %8d %8d %8d %8d  %8s\n";
    $sep = "-------- -------- -------- -------- -------- -------- -------- --------  --------\n";
    printf($header, "sfx", "sfx", "sfx", "", "sfx Not", "", "evx", "evx", "");
    printf($header, "Exchange", "Format", "Server", "sfx", "Imple-", "sfx", "TCP", "TCP", "Resolver");
    printf($header, "Error", "Error", "Fail", "Refused", "mented", "Other", "Fallback","Superior", "Index");

    print $sep;
    $totals = {};
    $six = 0;
    foreach my $server (sort (keys %{$localResolver->{Servers}})) {
	my $d = $localResolver->{Servers}->{$server}; # Reduce RSI
	printf($detail,
	       $d->{sfxExchangeError},
	       $d->{sfxFormatError},
	       $d->{sfxServerFail},
	       $d->{sfxRefused},
	       $d->{sfxNotImplemented},
	       $d->{sfxOther},
	       $d->{evxTCPFallback},
	       $d->{evxTCPSuperior},
	       $six);
	$six++;

	$totals->{sfxExchangeError} += $d->{sfxExchangeError};
	$totals->{sfxFormatError} += $d->{sfxFormatError};
	$totals->{sfxServerFail} += $d->{sfxServerFail};
	$totals->{sfxRefused} += $d->{sfxRefused};
	$totals->{sfxNotImplemented} += $d->{sfxNotImplemented};
	$totals->{sfxOther} += $d->{sfxOther};
	$totals->{evxTCPFallback} += $d->{evxTCPFallback};
	$totals->{evxTCPSuperior} += $d->{evxTCPSuperior};
    }
    print $sep;
    printf($detail,
	   $totals->{sfxExchangeError},
	   $totals->{sfxFormatError},
	   $totals->{sfxServerFail},
	   $totals->{sfxRefused},
	   $totals->{sfxNotImplemented},
	   $totals->{sfxOther},
	   $totals->{evxTCPFallback},
	   $totals->{evxTCPSuperior},
	   "Totals");
    print $sep;
}

sub printLocalResolverLegend {
    print "Index   Resolver IP\n";
    print "-----   ----------------------------------------\n";
    my $six = 0;
    foreach my $server (sort (keys %{$localResolver->{Servers}})) {
	printf("%5d   %s\n", $six, $server);
	$six++;
    }
    print "-----   ----------------------------------------\n";
}


##########

sub printDoHResolver() {
    printf("\n                              [DoH Resolver - input lines=%d]\n\n", $lines->{DoHResolver});
    if ($lines->{DoHResolver} == 0) {
	print STDERR "Warning: No DoH Resolvers found in log file\n" if $printWarnings;
	return;
    }
	
    &printDoHResolverGeneral();
    if (%{$DoHResolver->{Servers}}) {
        print "\n                              [DoH Errors]\n\n";
	&printDoHResolverErrors();
        print "\n                              [DoH Servers]\n\n";
	&printDoHResolverServers();
	print "\n                              [DoH Server Legend]\n\n";
	&printDoHResolverLegend();
    }
}

sub printDoHResolverGeneral() {
    my $header = "%8s %8s %8s %8s %8s\n";
    my $detail = "%8d %8d %8d %8d %8d\n";
    my $sep = "-------- -------- -------- -------- --------\n";
    printf($header, "", "", "", "dgx", "");
    printf($header, "Total", "Good", "Error", "PackDNS", "dgx");
    printf($header, "Reqs", "Reqs", "Reqs", "Query", "RFFU");
    print $sep;
    printf($detail,
	   $DoHResolver->{req},
	   $DoHResolver->{ok},
	   $DoHResolver->{errs},
	   $DoHResolver->{dgxPackDNSQuery},
	   $DoHResolver->{dgxRFFU});
    print $sep;
}

sub printDoHResolverErrors() {
    my $header = "%9s %9s %9s %9s %9s %9s %9s\n";
    my $detail = "%9d %9d %9d %9d %9d %9d %9s\n";
    my $sep = "--------- --------- --------- --------- --------- --------- ---------\n";

    printf($header, "Create", "Do", "Non", "Response", "Content", "Unpack", "Server");
    printf($header, "HTTPReq", "Requests", "StatusOk", "ReadAll", "Type", "DNSResp", "Index");
    print $sep;
    my $totals = {};
    $totals->{dexCreateHTTPRequest} = 0;
    $totals->{dexDoRequests} = 0;
    $totals->{dexNonStatusOk} = 0;
    $totals->{dexResponseReadAll} = 0;
    $totals->{dexContentType} = 0;
    $totals->{dexUnpackDNSResponse} = 0;

    my $six = 0;
    foreach my $server (sort (keys %{$DoHResolver->{Servers}})) {
	my $d = $DoHResolver->{Servers}->{$server};
	printf($detail,
	       $d->{dexCreateHTTPRequest},
	       $d->{dexDoRequests},
	       $d->{dexNonStatusOk},
	       $d->{dexResponseReadAll},
	       $d->{dexContentType},
	       $d->{dexUnpackDNSResponse},
	       $six);

	$six++;
	$totals->{dexCreateHTTPRequest} += $d->{dexCreateHTTPRequest};
	$totals->{dexDoRequests} += $d->{dexDoRequests};
	$totals->{dexNonStatusOk} += $d->{dexNonStatusOk};
	$totals->{dexResponseReadAll} += $d->{dexResponseReadAll};
	$totals->{dexContentType} += $d->{dexContentType};
	$totals->{dexUnpackDNSResponse} += $d->{dexUnpackDNSResponse};
    }
    print $sep;
    printf($detail,
	   $totals->{dexCreateHTTPRequest},
	   $totals->{dexDoRequests},
	   $totals->{dexNonStatusOk},
	   $totals->{dexResponseReadAll},
	   $totals->{dexContentType},
	   $totals->{dexUnpackDNSResponse},
	   "Totals");
    print $sep;
}

sub printDoHResolverServers() {
    my $header = "%8s %8s %8s %8s %8s %8s %8s %8s %8s %8s %8s\n";
    my $detail = "%8d %8.1f %8d %8d %8.3f %8.3f %8d %8d %8d %8d %8s\n";
    my $sep = "-------- -------- -------- -------- -------- -------- -------- -------- -------- -------- --------\n";

    printf($header, "Total", "Reqs/", "Good", "Error", "Total", "Remote", "ECS", "ECS", "ECS", "ECS", "Server");
    printf($header, "Reqs", "Second", "Reqs", "Reqs", "Latency", "Latency", "Removed", "Set", "Request", "Return", "Index");
    print $sep;

    my $totals = {};
    $totals->{ok} = 0;
    $totals->{totalLatency} = 0;
    $totals->{remoteLatency} = 0;
    $totals->{errs} = 0;
    $totals->{ECSRemoved} = 0;
    $totals->{ECSSet} = 0;
    $totals->{ECSRequest} = 0;
    $totals->{ECSReturned} = 0;

    my $six = 0;
    foreach my $server (sort (keys %{$DoHResolver->{Servers}})) {
	my $d = $DoHResolver->{Servers}->{$server};
	my $tl = $d->{totalLatency};
	my $rl = $d->{remoteLatency};
	if ($d->{ok} > 0) {
	    $tl /= $d->{ok};
	    $rl /= $d->{ok};
	}
	printf($detail,
	       $d->{ok}+$d->{errs},
	       $d->{ok} / $totalUptime,
	       $d->{ok},
	       $d->{errs},
	       $tl,
	       $rl,
	       $d->{ECSRemoved},
	       $d->{ECSSet},
	       $d->{ECSRequest},
	       $d->{ECSReturned},
	       $six);

	$six++;
	$totals->{ok} += $d->{ok};
	$totals->{totalLatency} += $d->{totalLatency};
	$totals->{remoteLatency} += $d->{remoteLatency};
	$totals->{errs} += $d->{errs};
	$totals->{ECSRemoved} += $d->{ECSRemoved};
	$totals->{ECSSet} += $d->{ECSSet};
	$totals->{ECSRequest} += $d->{ECSRequest};
	$totals->{ECSReturned} += $d->{ECSReturned};
    }

    print $sep;
    my $tl = $totals->{totalLatency};
    my $rl = $totals->{remoteLatency};
    if ($totals->{ok} > 0) {
	$tl /= $totals->{ok};
	$rl /= $totals->{ok};
    }
    printf($detail,
	   $totals->{ok}+$totals->{errs},
	   $totals->{ok} / $totalUptime,
	   $totals->{ok},
	   $totals->{errs},
	   $tl,
	   $rl,
	   $totals->{ECSRemoved},
	   $totals->{ECSSet},
	   $totals->{ECSRequest},
	   $totals->{ECSReturned},
	   "Totals");
    print $sep;
}

sub printDoHResolverLegend {
    print "Index   Server URL\n";
    print "-----   ------------------------------------------------------------\n";
    my $six = 0;
    foreach my $server (sort (keys %{$DoHResolver->{Servers}})) {
	printf("%5d   %s\n", $six, $server);
	$six++;
    }
    print "-----   ------------------------------------------------------------\n";
}
